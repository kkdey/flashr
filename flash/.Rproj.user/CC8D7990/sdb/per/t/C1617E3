{
    "contents" : "#' title ash type model for f\n#'\n#' description use ash type model to maxmization\n#'\n#' @return Ef is the mean of f Ef2 is mean of f^2\n#'\n#' @keywords internal\n\n# El is expectation of l, and El2 is the second moment of l, sigmae2 is estimation of sigmae^2\nATM_f = function(Y,El,El2,sigmae2){\n  sum_El2 = sum(El2)\n  sebeta = sqrt( sigmae2/(sum_El2) )\n  betahat = (t(El) %*% Y) / (sum_El2)\n  # betahat=(sum(l^2))^(-1)*(t(l)%*%Y)\n  betahat=as.vector(betahat)\n  ATM = ash(betahat, sebeta, method=\"fdr\", mixcompdist=\"normal\")\n  Ef = ATM$PosteriorMean\n  SDf = ATM$PosteriorSD\n  Ef2 = SDf^2 + Ef^2\n  return(list(Ef = Ef, Ef2 = Ef2))\n}\n\n#' title ash type model for l\n#'\n#' description use ash type model to maxmization\n#'\n#' @return El is the mean of l,  El2 is mean of l^2\n#'\n#' @keywords internal\n#'\nATM_l = function(Y,Ef,Ef2,sigmae2){\n  sum_Ef2 = sum(Ef2)\n  sebeta = sqrt(sigmae2/(sum_Ef2))\n  betahat = (t(Ef) %*% t(Y)) / (sum_Ef2)\n  # betahat=(sum(f^2))^(-1)*(t(f)%*%t(Y))\n  betahat=as.vector(betahat)\n  ATM = ash(betahat, sebeta, method=\"fdr\", mixcompdist=\"normal\")\n  El = ATM$PosteriorMean\n  SDl = ATM$PosteriorSD\n  El2 = SDl^2 + El^2\n  return(list(El = El, El2 = El2))\n}\n\n\n# Fval = function()\n\n\n\n\n\n\n\n#' Factor Loading Adaptive Shrinkage (VEM version)\n#'\n#' flash provide rank one matrix decomposition\n#'\n#' @param Y is the data matrix (N by P)\n#' @param tol which is the stop criterion for the convergence, default is 1e-5\n#' @param numtau number of iteration, default is 500. for the backfitting case, the number of tau should be 5 or 10.\n#'\n#' @details flash privide rank one matrix decomposition with variational EM algorithm.\n#'\n#' @export flash\n#'\n#' @importFrom ashr ash\n#'\n#' @return list of factor, loading and variance of noise matrix\n#'  \\itemize{\n#'   \\item{\\code{l}} {is a N vector for loadings}\n#'   \\item{\\code{f}} {is a P vector for factors}\n#'   \\item{\\code{sigmae2}} {is mean of sigma square which is estimation for the noise variance}\n#'  }\n#' @examples\n#' N = 100\n#' P = 200\n#' Y = matrix(rnorm(N*P,0,1),ncol=P)\n#' g = flash(Y)\n#'\n\n\n# set the number of iteration as numtau\nflash = function(Y,tol=1e-6,numtau = 500){\n  #dealing with missing value\n  Y[is.na(Y)] = 0\n  # get initial value for l and f and sigmae\n  El = svd(Y)$u[,1]\n  El2 = El^2\n  Ef = as.vector(t(El)%*%Y)\n  Ef2 = Ef^2\n\n  #start iteration\n  sigmae2_v = mean( Y^2 - 2*Y*(El %*% t(Ef)) + (El2 %*% t(Ef2)) )\n\n  par_f = ATM_f(Y,El,El2,sigmae2_v)\n  Ef = par_f$Ef\n  Ef2 = par_f$Ef2\n\n  sigmae2_v = mean( Y^2 - 2*Y*(El %*% t(Ef)) + (El2 %*% t(Ef2)) )\n  #sigmae2\n  par_l = ATM_l(Y,Ef,Ef2,sigmae2_v)\n  El = par_l$El\n  El2 = par_l$El2\n\n  epsilon = 1\n  tau = 1\n  while(epsilon >= tol & tau < numtau ){\n    tau = tau + 1\n    pre_sigmae2 = sigmae2_v\n\n    sigmae2_v = mean( Y^2 - 2*Y*(El %*% t(Ef)) + (El2 %*% t(Ef2)) )\n\n    par_f = ATM_f(Y,El,El2,sigmae2_v)\n    Ef = par_f$Ef\n    Ef2 = par_f$Ef2\n    if(sum(Ef^2)==0){\n      l = 0\n      f = 0\n      break\n    }\n    sigmae2_v = mean( Y^2 - 2*Y*(El %*% t(Ef)) + (El2 %*% t(Ef2)) )\n    #sigmae2\n    par_l = ATM_l(Y,Ef,Ef2,sigmae2_v)\n    El = par_l$El\n    El2 = par_l$El2\n    if(sum(El^2)==0){\n      l = 0\n      f = 0\n      break\n    }\n    epsilon = abs(pre_sigmae2 - sigmae2_v )\n  }\n  return(list(l = El, f = Ef, sigmae2 = sigmae2_v))\n}\n",
    "created" : 1455153524123.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3602924914",
    "id" : "C1617E3",
    "lastKnownWriteTime" : 1455153357,
    "path" : "~/HG/ash-sfa/Rcode/postmean/flash/flash/R/flash_VEM.R",
    "project_path" : "R/flash_VEM.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}